## Basic  of Vectorsnotions
1) Physics: Vector: arrow pointing spaces, direction+length, 2-3dimen., can set everywhere

2) CS: 2 or more dimen. lists(rows and colums)

3) Math: can be anything-1) and 2), O: addition, multiply
        sum of two vectors=from T of 1st and end at H of 2nd
                          =CS-way also O used for addition, + same positions
        multiply= streching by copying in a specific proport.
                = CS- way: multiply the constant to each factor

- x-y axis: tail starts from 0(Origin) <-> Physics
            CS-way can be used-> express vectors'form
- 3dimen: CS-way has 3rows

- Scaling: stretching/squishing/reversing the direct.
  Scalars: 2, 1/3, -1.8.. etc.

## forming vectors

import numpy as np
# import numpy function. has an speciality in calcu. vect.and rows&colums.

# ===== forming vectors =====
v = np.array([3., 4.])
# v = (3, 4)-> the reason of putt' dots: 
dots-> not int, float-> float is safer for norm/angle calcu 
                        + prevent err. occur' when int->float.

w = np.array([1., -2.])
# same with 26-28

# ===== forming vector norm and unit vector =====
v_norm = np.linalg.norm(v)
# ||v||2 = sqrt(3^2 + 4^2) = 5.
c.f.) Euclid norm: length of vectors(scalar)
        L1 norm (Manhattan norm): the distance as the sum of absolute values of coordinates, 
                                like walking along grid lines.
                                ∥v∥1​=∑∣xi​∣
        L2 norm (Euclidean norm): the straight-line distance, 
                                computed as the square root of the sum of squared coordinates.
                                ∥v∥2​=sqrt∑(xi^2)​
        L∞ norm (Maximum norm): the largest absolute coordinate, 
                                showing the farthest extent along any axis.
                                ∥v∥∞​=max∣xi​∣

v_unit = v / v_norm if v_norm != 0 else v
# unit vector: v̂ = v / ||v|| (vector) *except.-> denominator=0
norm of unit vector: always 1
b/c) 
v̂ = v / ||v||
||v̂||   = sqrt( Σ (vi / ||v||)^2 )
        = sqrt( Σ vi^2 ) / ||v||
        = ||v|| / ||v|| = 1


# ===== forming dot & angle =====
dot_vw = float(np.dot(v, w))
# dot: suggest that in respect of w = v->w projection,
        to which direction(the length of shadow=||v||cosθ) + to what extent(multiply ||w||) 
        = work(in Physics)
        => v·w = ||v||||w||cosθ-> sign is differ depend' on cosθ,
                                 the sign of dot: 0-> vertical, (+)-> same direct., (-)-> reverse direct. 
                                -> O guess the range of angle, catch the direction
                                -> but it b/c of cos, not ||v||||w||(just multiply b/w scal.)           
                = v1*w1 + v2*w2 + ...
                = ∑vi​wi​
                b/c) For any triangle with sides a,b,c: c^2=a^2+b^2−2abcosθ
                ∣a−b∣^2=∣a∣^2+∣b∣^2−2∣a∣∣b∣cosθ (apply that to vec.) -(1)
                ∣a−b∣^2=1∑n​(ai​−bi​)^2=∑ai^2​+∑bi^2​−2∑ai​bi -(2)
                in apply (2) to (1),
                −2∣a∣∣b∣cosθ=−2∑ai​bi
                => ​dot=∣a∣∣b∣cosθ=1∑n​ai​bi​

cos_theta = dot_vw / (np.linalg.norm(v) * np.linalg.norm(w))
# see the 62

cos_theta = np.clip(cos_theta, -1.0, 1.0)
# Floating-point error: com. store num. in binary approx.
                        -> results can be slightly off (e.g., 1.0000000002 instead of 1.0). 
                        -> This can push values like cosθ just outside the valid range [-1,1].
                        -> err. occur when use arccos
Clipping: forc' a value -> a safe range by cutt' it off. 

theta_deg = np.degrees(np.arccos(cos_theta))
# θ = arccos(cosθ) (radian) → degrees() (turn into degree)
e.g) arccos(0.5)=1.04719(π/3​)-> degrees(arccos(0.5))=60∘

# ===== forming cross=====
cross_vw = np.cross(v, w)
#Cross: the parallelogram-area that is consisted of two vec. and vertical to the two vec. (vector), called as normal vector(normal line=vertical line) 
        1) magnitude = ∣𝑎∣∣𝑏∣sin𝜃 (the formula of parallelogram-area)
        2) dirct. = determ. by right hand rule(bend 4fin. from one's direct. to another's and check the direct. your thumb points)
        mutiply 1) & 2) => cross
unit vector: 
form of formula: use rows&colums just to make ez to rememb.
  a × b = | i   j   k  |
          | a1  a2  a3 |
          | b1  b2  b3 |
in that form, i, j, k - unit vect. that are used for express each axis(direct.)
a=(a1i, a2j, a3k), b=(b1i, b2j, b3k)
a×b=(a1​i+a2j+a3k)×(b1i​+b2j​+b3k​) (form of vect.=sum of values of each axis)
        = a1​i×b1​i + a1​i×b2​j + a1​i×b3​k + a2​j×b1​i + a2​j×b2​j + a2​j×b3​k + a3​k×b1​i + a3​k×b2​j + a3​k×b3​k
        = 0 + a1​b2​(i×j) + a1​b3​(i×k) + a2​b1​(j×i) + 0 + a2​b3​(j×k) + a3​b1​(k×i) + a3​b2​(k×j) + 0
        = 0 + a1b2k + (-a1b3j)+ (-a2b1k) + 0 + a2b3i + a3b1j + (-a3b2i) + 0
b/c) cross of same direction= parall.-> no area forms-> 0
        e.g.) i×j = ∣i∣∣j∣sin90∘*k=1*1*1*k=k (the norm of unit vect. is always 1 + k direct.(b/c k is the only direct. vertical to both i&j + x->y is (+) sign))
                
# ===== forming distance b/w two vec. =====
dist_vw = np.linalg.norm(v - w)
# Euclidean distance: straight line distance=||v - w||, point-to-point distance formula-> O apply to n-dimen.

# ===== result output =====
print(f"v = {v}, ||v|| = {v_norm:.3f}, v_unit = {v_unit}")
#f: f-string (formatted string literal), if use {}-> real value
e.g.) name = "Alice"
        print(f"Hello {name}!") = the outcome is "Hello Alice!"
.3f: output float up to 3 decimal places
e.g.) num = 3.141592
        print(f"num = {num:.3f}") = the outcome is "num = 3.141"

print(f"w = {w}")
# see the 115-120

print(f"dot(v, w) = {dot_vw:.3f}")
# see the 115-120

print(f"angle(v, w) = {theta_deg:.3f} degrees")
# angle(v,w): the angle b/w v and w

print(f"dist(v, w) = {dist_vw:.3f}")
# see the 115-120

print(f"cross(v, w) = {cross_vw:.3f}")
# see the 115-120









            
